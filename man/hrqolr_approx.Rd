% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hrqolr_approx.R
\name{hrqolr_approx}
\alias{hrqolr_approx}
\title{Interpolate multiple values}
\usage{
hrqolr_approx(x, y, xout, yleft = -Inf, yright = Inf, method = 1, f = 0)
}
\arguments{
\item{x, y}{numeric vectors giving the coordinates of the points to be
    interpolated.  Alternatively a single plotting structure can be
    specified: see \code{\link{xy.coords}}.}

\item{xout}{an optional set of numeric values specifying where
    interpolation is to take place.}

\item{yleft}{the value to be returned when input \code{x} values are
    less than \code{min(x)}. The default is defined by the value
    of \code{rule} given below.}

\item{yright}{the value to be returned when input \code{x} values are
    greater than \code{max(x)}. The default is defined by the value
    of \code{rule} given below.}

\item{method}{specifies the interpolation method to be used.  Choices
    are \code{"linear"} or \code{"constant"}.}

\item{f}{for \code{method = "constant"} a number between 0 and 1
    inclusive, indicating a compromise between left- and
    right-continuous step functions. If \code{y0} and \code{y1} are
    the values to the left and right of the point then the value is
    \code{y0} if \code{f == 0}, \code{y1} if \code{f == 1}, and
    \code{ y0*(1-f)+y1*f} for intermediate values. In this way the result is
    right-continuous for \code{f == 0} and left-continuous for \code{f
    == 1}, even for non-finite \code{y} values.}
}
\value{
Interpolated values
}
\description{
Stripped-down version of \code{\link[stats:approxfun]{stats::approx()}}. The underlying C code is exactly the same but included in
\code{hrqolr} as it's unexported from the \code{stats} package.
}
\keyword{internal}
